% Usage:
%   For entire gstats structure reducing:
%     function [gs_struct new_count] = foldreduce(foldmat,gs_input);
%     function [gs_struct new_count] = foldreduce(foldmat,gs_input,'dayspan',dayspan);
%     function [gs_struct new_count] = foldreduce(foldmat,gs_input, ... ,'chan',chan_sel);
%   For single field reducing: 
%     function [new_dat new_count new_std] = foldreduce(foldmat,count,dat,dat_std);
%
% Inputs:
%   foldmat  - fold matrix generated by mkfold()
%   count    - the *_count fieled, if no *_count field is available use npro
%   dat      - input dataset to be folded
%   dat_std  - input dataset stdev to be folded
%  - or -
%   foldmat  - fold matrix generated by mkfold()
%   gs_input - the './gsx_folder' name
%   dayspan  - day span to average over (works with folders ONLY)
%                [16] - for 16 day span
%                [datenum(2002,9,7) 16] - 16 day span starting from 7 Sep 2002
%                [datenum(2004,1,1) 8 datenum(2005,1,1)] - 8 day span for 1 year
%                [0 1 0] - monthly averages for all time
%                [datenum(2002,9,7) 0 1 0] - monthly averages starting 7 Sep 2002
%   chan_sel - subset a given set of channels (works with folders ONLY)
%
% Note:
%   Full dayspan format is [start_date  year_step  month_step  day_step  end_date]
%
% Output:
%   new_dat   - dataset re-folded
%   new_count - counts re-folded
%   new_std   - stdev re-folded
%  - or -
%   gs_struct - gs data structure with appropriate folds
%   new_count - new npro counts (also in new_struct.npro)
%
% Example of reducing a single day:
%   fn='./gsx_1dayV1_ecmwf';  % folder name
%   [myFold gtops] = mkfold(fn,'rlat','keep','landfrac',[0 .001],'solzen',[90 180]);
%   data_structure = foldreduce(myFold,fn,datenum(2002,9,29)); 
%
% Example of folder reducing:
%   fn='./gsx_1dayV1_ccc';  % folder name
%   [myFold gtops] = mkfold(fn,'rlat','keep','landfrac',[0 .001],'solzen',[90 180]);
%   data_structure = foldreduce(myFold,fn); 
%   %data_structure = foldreduce(myFold,fn,16);  % to make 16 day averages
%
% Example of single field:
%   [myFold new_gtops] = mkfold(gtops,'rlat',-30:10:30);
%   new_rcalc = foldreduce(myFold,npro,rcalc_avg,rcalc_std); % use npro for non *_count fields
%   new_robs1 = foldreduce(myFold,robs1_count,robs1_avg,robs1_std);
%   plot(new_gtops.freq,new_robs1(:,:,1)-new_rcalc(:,:,1));
%   %plot(new_gtops.freq,new_robs1-new_rcalc);
%   legend(num2str((-25:10:30)'));ylim([-2 2])

%function [new_dat new_count new_std] = foldreduce(foldmat,count,dat,dat_std);
function [new_dat new_count new_std] = foldreduce(foldmat,varargin);


if nargin < 2
  error('FOLDREDUCE: First argument must be the fold matrix, and the rest data.');
end

% Process a mat-file as a gs_input and continue to the structure processing
%if isstr(varargin{1}) & exist(varargin{1},'file')
%  varargin{1} = load(varargin{1});
%end

% Process a structure as a gs_input
if isstruct(varargin{1})
  %error('Gstats path expected, but a structure was found.')
  if nargin > 2; disp('Warning: no date/channel subsetting applied; use a folder name instead.'); end
  if isfield(varargin{1},'npro')
    dat = varargin{1};
    count = dat.npro;
  else
    %keyboard; return;
    error('FOLDREDUCE: npro not specified in structure')
  end

  names = fieldnames(dat);
  avg_names = names(find(~cellfun(@isempty,regexp(names,'_avg$'))));
  new_dat = struct;
  new_count = [];
  for i = 1:length(avg_names)
    if isfield(dat,[avg_names{i}(1:end-4) '_std'])
      if isfield(dat,[avg_names{i}(1:end-4) '_count'])
        %disp(['[new_dat.' avg_names{i} ' new_dat.' avg_names{i}(1:end-4) '_count new_dat.' ...
        %     avg_names{i}(1:end-4) '_std]=' ...
        %     'foldreduce(foldmat,dat.' avg_names{i}(1:end-4) '_count,dat.' avg_names{i} ',dat.' avg_names{i}(1:end-4) '_std);'])
        eval(['[new_dat.' avg_names{i} ' new_dat.' avg_names{i}(1:end-4) '_count new_dat.' ...
             avg_names{i}(1:end-4) '_std]=' ...
             'foldreduce(foldmat,dat.' avg_names{i}(1:end-4) '_count,dat.' avg_names{i} ',dat.' avg_names{i}(1:end-4) '_std);'])
      else
        %disp(['[new_dat.' avg_names{i} ' new_count new_dat.' avg_names{i}(1:end-4) '_std]=' ...
        %     'foldreduce(foldmat,count,dat.' avg_names{i} ',' avg_names{i}(1:end-4) '_std);'])
        eval(['[new_dat.' avg_names{i} ' new_count new_dat.' avg_names{i}(1:end-4) '_std]=' ...
             'foldreduce(foldmat,count,dat.' avg_names{i} ',dat.' avg_names{i}(1:end-4) '_std);'])
      end
    else
      if isfield(dat,[avg_names{i}(1:end-4) '_count'])
        eval(['[new_dat.' avg_names{i} ' new_dat.' avg_names{i}(1:end-4) '_count]='...
             'foldreduce(foldmat,dat.' avg_names{i}(1:end-4) '_count,dat.' avg_names{i} ');'])
      else
        eval(['[new_dat.' avg_names{i} ' new_count]=foldreduce(foldmat,count,dat.' avg_names{i} ');'])
      end
    end
  end

  if isfield(dat,'npro')
    new_dat.npro = new_count;
  end

  return
end

files_loaded = 0;
start_time = datenum(clock); % start the stopclock for time estimation

% Process a directory as a gs_input
if isstr(varargin{1}) && exist(varargin{1},'dir')
  dname = varargin{1};
  dayspan = [];
  chan_sel = [];
  if nargin == 3; dayspan = varargin{2}; else
    for i = 3:2:length(varargin)
      if strcmp(varargin{i-1},'chan'); chan_sel = varargin{i}; end
      if strcmp(varargin{i-1},'dayspan'); dayspan = varargin{i}; end
    end
  end

  if isempty(dayspan) & isempty(chan_sel)
    %  Load in every file in the directory, if they are in 1 day increments then it will be one 
    %   element per day, etc...
    %
    disp(['Loading directory: ' dname])
    files = findfiles([dname '/*.mat']);
    for i = 1:length(files)
      % display some simple stats after 3 files have been processed
      if i < 3
        disp(['  ' files{i} '  (' num2str(i) ' of ' num2str(length(files)) ')']);
      else
        d_time = datenum(clock) - start_time; % delta time
        disp(['  ' files{i} '  (' num2str(i) ' of ' num2str(length(files)) ' - ' ...
          datestr(d_time/(i-1)*(length(files)-i+1),13) ')'])
      end

      % load the file in and foldreduce the file
      try
        tmp = foldreduce(foldmat,load(files{i}));
        if isstruct(tmp); gs_struct(i) = tmp; end
      catch e
        %keyboard; return
        % if the file is empty or failed, then display an error
        disp('    error - file either empty or has no relevant data')
      end
    end
  else
    %  Load in a day span from a given directory, so if one asks for every 6 days to be binned
    %   together, then we will load up the chunks of 6 days and then reduce it into one chunk.
    %
    % figure out what the dayspan input vector really means: 
    %   format:  dayspan = [start_date  year_step  month_step  day_step  end_date]
    if length(dayspan) == 1 && dayspan < 100; dayspan = [datenum(2002,9,7) 0 0 dayspan datenum(clock)]; end
    if length(dayspan) == 1 && dayspan > 100; dayspan = [dayspan 0 0 1 dayspan]; end
    if length(dayspan) == 2; dayspan = [dayspan(1) 0 0 dayspan(2) datenum(clock)]; end
    if length(dayspan) == 3;
      % A tricky input, do we mean [start step end] or [year_step month_step day_step] ?
      %   We probably won't be averaging over 10000+ days at a time so it is safe to do:
      if dayspan(1) < 10000; 
        % if this is monthly then lets zero out the start day
        if dayspan(3) > datenum(clock); dayspan = [datenum(2002,1,1) dayspan datenum(clock)];
          else dayspan = [datenum(2002,9,7) dayspan datenum(clock)]; end
      else
        dayspan = [dayspan(1) 0 0 dayspan([2 3])];
      end
      %%%OLD WAY
      %if dayspan(1) < 10000; dayspan = [datenum(2002,9,7) dayspan datenum(clock)];
      %  else; dayspan = [dayspan(1) 0 0 dayspan(2:3)]; end
    end
    if length(dayspan) == 4; dayspan = [dayspan datenum(clock)]; end

    % now lets begin:
    disp(['Loading directory by dayspan: ' dname ' starting at ' datestr(dayspan(1))])

    start_time = datenum(clock); % start the stopclock for time estimation
    files_rescan = 0;

    day = dayspan(1);
    i = 1;
    while day <= dayspan(5)
      files = []; 

      day_end = datenum(datevec(day)+[dayspan(2:4) 0 0 0])-1;
      for j = day:day_end
        ds = datestr(j,'yyyymmdd');
        files = [files findfiles([dname '/*_' ds '.mat'])];
      end
      if isempty(files); day = day_end + 1; continue; end

      % every 100 files, rescan the directory contents to update our eta
      %if files_loaded >= files_rescan
      %  files_total = length(findfiles([dname '/*.mat']));
      %  files_rescan = files_rescan + 100;
      %end
      

      % display some simple stats after 10 files have been processed
      if files_loaded < 10
        disp(['  Bin(' num2str(i) ') processing: ' datestr(day,'yyyymmdd') '-' datestr(day_end,'yyyymmdd')])
      else
        d_time = datenum(clock) - start_time; % delta time
        %disp(['  Bin(' num2str(i) ') processing: ' datestr(day,'yyyymmdd') '-' datestr(day_end,'yyyymmdd') '   ' ...
        %  'eta: ' datestr(d_time/(files_loaded-1)*(files_total-files_loaded+1),13)])
        disp(['  Bin(' num2str(i) ') processing: ' datestr(day,'yyyymmdd') '-' datestr(day_end,'yyyymmdd') '   ' ...
          'eta: ' datestr(d_time/(day-dayspan(1))*(dayspan(5)-day),13)])
      end
      files_loaded = files_loaded + length(files);

      for f = 1:length(files)
        if length(files) > 1
          disp(['  ' files{f} '  (' num2str(f) ' of ' num2str(length(files)) ')']);
        else
          disp(['  ' files{f}]);
        end

        % load the file in and foldreduce the file
        try
          %tmp(f) = foldreduce(foldmat,load(files{f}));
          dat = rmfield(load(files{f}),'gtops');
          dat = structfun(@(x) (growint(x)),dat,'UniformOutput',false);
          if ~isempty(chan_sel)
            names = fieldnames(dat);
            chan_names = names(find(~cellfun(@isempty,regexp(names,'^robs')) | ~cellfun(@isempty,regexp(names,'^rcalc'))));
            for fname = chan_names'
              eval(['dat.' fname{1} '=dat.' fname{1} '(chan_sel,:,:);'])
            end
          end

          if ~isfield(dat,'npro'); 
            disp('    error - file has no profiles')
          elseif length(fieldnames(dat)) < 4
            disp('    error - file has less than 4 fields')
          else
            % compare and match the structures
            if exist('tmp','var')
              for field_diff = setxor(fieldnames(tmp),fieldnames(dat))'
                %disp(['Removing field: ' field_diff{1}])
                if isfield(dat,field_diff{1})
                  dat = rmfield(dat,field_diff{1});
                else
                  tmp = rmfield(tmp,field_diff{1});
                end
              end
            end
            tmp(f) = orderfields(dat);
          end
        catch e
          dbstack
          %keyboard; return
          % if the file is empty or failed, then display an error
          disp('    error - file either empty or has no relevant data')
        end
      end

      % If there is no data for this day span skip it
      if ~exist('tmp','var');
        day = day_end + 1;
        continue;
      end

      % put everything into one structure
      tmp = structmerge(tmp,3);

      if length(fieldnames(tmp)) == 0; 
        disp('  - no data');
      elseif length(fieldnames(tmp)) < 4
        disp('  - file has less than 4 fields, probably empty (skipping)')
      else
        disp(['    - refolding ' num2str(size(foldmat,1)) ' to ' num2str(size(foldmat,2)) ' -'])
        tmp = foldreduce(foldmat,tmp);
        % flip the folds and days around then average the days
        disp(['    - time binning ' num2str(size(tmp.npro,3)) ' files -'])
        tmp = foldreduce(ones([size(tmp.npro,3) 1]),structfun(@(x) (permute(x,[1 3 2])),tmp,'UniformOutput',false));
        % flip the days and folds around and then store
        try
            if exist('gs_struct','var')
              for field_diff = setxor(fieldnames(tmp),fieldnames(gs_struct))'
                %disp(['Removing field: ' field_diff{1}])
                if isfield(gs_struct,field_diff{1})
                  gs_struct = rmfield(gs_struct,field_diff{1});
                else
                  tmp = rmfield(tmp,field_diff{1});
                end
              end
            end
          gs_struct(i) = structfun(@(x) (permute(x,[1 3 2])),tmp,'UniformOutput',false);
        catch e; 
           disp('    no data - or structures are dissimilar');
           %keyboard;
        end
      end
      clear tmp

      day = day_end + 1;i = i + 1;
    end
  end

  % merge the struct array into one structure
  if ~exist('gs_struct','var'); new_dat = struct; return; end
  new_dat = structmerge(gs_struct,3);

  disp(['Files loaded: ' num2str(files_loaded)])
  disp(['Time lapsed: ' datestr(-start_time + datenum(clock),13)])
  stat = whos('new_dat');
  disp(['Size in MB: ' num2str(stat.bytes/1024/1024,'%0.2f')])

  % This would probably be a good idea to return the subset channel list, but I don't want to support this... yet
  %try
  %  load(files{f},'gtops')
  %  if ~isempty(chan_sel)
  %    new_dat.freq = gtops.freq(chan_sel);
  %  else
  %    new_dat.freq = gtops.freq;
  %  end
  %catch; end
  
  return
end

% Now to the core of the function, past now the given loaders and file handlers:

count = varargin{1};
dat = varargin{2};
if nargin > 3
  dat_std = varargin{3};
end

if size(count,2) ~= size(foldmat,1)
  error('FOLDREDUCE: The foldmat dim 1 and number of folds in given counts must match in size')
end

if size(dat,2) ~= size(foldmat,1)
  error('FOLDREDUCE: The foldmat dim 1 and number of folds in given dataset must match in size')
end

if ~(size(dat,1) == size(count,1) | size(count,1) == 1)
  error('FOLDREDUCE: counts must match the size of dat on the first dimension or be size 1 x N');
end
if size(dat,2) ~= size(count,2)
  error('FOLDREDUCE: counts must match the size of dat on the second dimension');
end
if nargin > 3 & ~(isequal(size(dat),size(dat_std)) | isempty(dat_std))
  error('FOLDREDUCE: data and stdev must match in size');
end
if (nargin < 4 | isempty(dat_std)) & nargout > 2
  error('FOLDREDUCE: new_std requested although dat_std not provided');
end

% prepare memory space for the new dataset
new_count = zeros([size(count,1) size(foldmat,2) size(count,3)]);
new_dat = zeros([size(dat,1) size(foldmat,2) size(dat,3)]);
if nargin > 3 & nargout > 2
  new_dat2= zeros([size(dat_std,1) size(foldmat,2) size(dat_std,3)]);
end

% loop over the third dimension (if there is one)
for k = 1:size(dat,3)
  new_count(:,:,k) = squeeze(new_count(:,:,k)) + nandot(squeeze(double(count(:,:,k))) , foldmat);
  if size(count,1) ~= size(dat,1)
    n = squeeze(repmat(count(:,:,k),[size(dat,1) 1 1]));
    nm1 = squeeze(int32(repmat(count(:,:,k),[size(dat,1) 1 1]))-1);
  else
    n = squeeze(count(:,:,k));
    nm1 = squeeze(int32(count(:,:,k))-1);
  end
  n = double(n); nm1 = double(nm1);
  dat1 = squeeze(double(dat(:,:,k))) .* n;
  new_dat(:,:,k) = nanadd(squeeze(new_dat(:,:,k)), nandot(dat1, foldmat));
  if nargin > 3 & nargout > 2
    dat2 = (squeeze(dat_std(:,:,k).^2) + dat1.*dat1./(n.*nm1)).*nm1;
    dat2(n == 1) = dat1(n == 1) .^ 2;
    new_dat2(:,:,k) = nanadd(squeeze(new_dat2(:,:,k)), nandot(dat2 , foldmat));
  end
  %new_count = accumarray(foldmat,dat_std.*count);
end

% put together the total counts for calculations
if size(count,1) ~= size(dat,1)
  n = repmat(new_count,[size(dat,1) 1 1]);
  nm1 = repmat(new_count,[size(dat,1) 1 1])-1;
else
  n = new_count;
  nm1 = new_count-1;
end

% return standard dev
if nargin > 3 & nargout > 2
  new_std = sqrt(abs(new_dat2./nm1 - new_dat.*new_dat./(n.*nm1)));
  new_std = cast(new_std,class(dat_std));
end
% return mean
new_dat = cast(new_dat./n,class(dat));
new_count = uint32(new_count);

end

% Misc functions used in the above for easy reading
function c = nanadd(a,b)
  a(isnan(a)) = 0;
  b(isnan(b)) = 0;
  c = a + b;
end
function c = nandot(a,b)
  a(isnan(a)) = 0;
  b(isnan(b)) = 0;
  c = a * b;
end
function a = growint(a)
  t = class(a);
  if strcmp(t(1:4),'uint')
    a = uint32(a);
  end
end
